# -*- coding: utf-8 -*-
"""25thFeb.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BYxrdMwLdo0iqiMmqHrwXWqOolparsLe

# Context Manager
"""

def simple_file_write() -> None:
    """
    Demonstrates built-in context manager for file I/O.
    """
    with open("/content/blah.txt", "w", encoding="utf-8") as file:
        file.write("Hello, context manager!\n")

# Python program creating a
# context manager

class ContextManager:
    """
    Simple demonstration of a Context Manager
    """
    def __init__(self) -> None:
        print('init method called')

    def __enter__(self) -> 'ContextManager':
        print('enter method called')
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback) -> None:
        print('exit method called')


with ContextManager() as manager:
    print('with statement block')

# Python program showing file management using context manager
from typing import Any, Optional, TextIO, Type


class FileManager:
    def __init__(self, filename: str, mode: str) -> None:
        self.filename = filename
        self.mode = mode
        self.file: Optional[TextIO] = None

    def __enter__(self) -> TextIO:
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_value: Optional[BaseException],
        exc_traceback: Optional[Any]
    ) -> None:
        if self.file:
            self.file.close()


# Loading a file
with FileManager("/content/blah.txt", 'w') as f:
    f.write('Test')

print(f.closed)

# Using Contextlib and Decorator example
import contextlib
from typing import Generator, TextIO

@contextlib.contextmanager
def open_file(path: str, mode: str) -> Generator[TextIO, None, None]:
    """
    A generator-based context manager that opens and closes a file.
    """
    f = open(path, mode, encoding="utf-8")
    try:
        yield f
    finally:
        f.close()

def contextlib_example() -> None:
    """
    Demonstrates usage of a generator-based context manager with contextlib.
    """
    with open_file("/content/blah.txt", "w") as f:
        f.write("Hello from contextlib!\n")

"""# Decorators"""

# Basic Decorators

from typing import Callable, Any

def hello_decorator(func: Callable[..., str]) -> Callable[..., str]:
    """
    A decorator that prints 'Hello!' before calling the original function.
    """
    def wrapper(*args: Any, **kwargs: Any) -> str:
        print("Hello!")
        result = func(*args, **kwargs)
        return result
    return wrapper

@hello_decorator
def greet(name: str) -> str:
    """
    Returns a greeting for the specified name.
    """
    return f"Nice to meet you, {name}."


print(greet("Hemanth"))

#Logging Function calls

def log_decorator(func: Callable[..., Any]) -> Callable[..., Any]:
    """
    A decorator that logs the function name and arguments before execution.
    """
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        print(f"Calling {func.__name__} with args={args} kwargs={kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log_decorator
def add(x: int, y: int) -> int:
    """
    Returns the sum
    """
    return x + y


result = add(3, 4)
print("Result:", result)

# Decorator with Arguments

def repeat(num_times: int) -> Callable:
    """
    A decorator factory that repeats the wrapped function num_times times.
    """
    def decorator(func: Callable[..., None]) -> Callable[..., None]:
        def wrapper(*args: Any, **kwargs: Any) -> None:
            for _ in range(num_times):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def say_hi() -> None:
    print("Hi!")

say_hi()

"""### Class Based Decorators"""

class CallCounter:
    """
    A class-based decorator that counts how many times a function is called.
    """

    def __init__(self, func: Callable[..., Any]) -> None:
        self.func = func
        self.count = 0

    def __call__(self, *args: Any, **kwargs: Any) -> Any:
        self.count += 1
        print(f"[CallCounter] {self.func.__name__} called {self.count} times.")
        return self.func(*args, **kwargs)

@CallCounter
def greet_person(name: str) -> str:
    return f"Hello, {name}!"

print(greet_person("Hem"))
print(greet_person("Anth"))
print(greet_person("Lakshman"))

# Class Decorator with Parameters

def call_counter_factory(verbose: bool = True):
    """
    Factory returning a class-based decorator that can be verbose or not.
    """

    class CallCounterFactory:
        def __init__(self, func: Callable[..., Any]) -> None:
            self.func = func
            self.count = 0

        def __call__(self, *args: Any, **kwargs: Any) -> Any:
            self.count += 1
            if verbose:
                print(f"[Count] {self.func.__name__} = {self.count}")
            return self.func(*args, **kwargs)

    return CallCounterFactory

@call_counter_factory(verbose=False)
def silent_greet(name: str) -> str:
    return f"Hi, {name}!"

@call_counter_factory(verbose=True)
def verbose_greet(name: str) -> str:
    return f"Hi, {name}!"

print(verbose_greet("Hem"))
print(verbose_greet("Lak"))

print(silent_greet("Hem"))
print(silent_greet("Lak"))

# Decorating Class methods:
def uppercase_method(func: Callable[..., str]) -> Callable[..., str]:
    """
    Decorator that uppercases the return value of a method.
    """
    def wrapper(*args: Any, **kwargs: Any) -> str:
        result = func(*args, **kwargs)
        return result.upper()
    return wrapper

class Greeter:
    @uppercase_method
    def say_hi(self, name: str) -> str:
        return f"Hi, {name}"

greeter = Greeter()
print(greeter.say_hi("Hemanth"))

"""# Callable"""

#basic callable function

def add(a: int, b: int) -> int:
    """
    Returns the sum of a and b.
    """
    return a + b

result = add(8, 7)
print("Result:", result)

# Callable Class with __call__ Method

class Multiplier:
    """
    A class that becomes a callable object by defining __call__.
    """

    def __init__(self, factor: int) -> None:
        self.factor: int = factor

    def __call__(self, value: int) -> int:
        return value * self.factor


times_five = Multiplier(10)
print(times_five(10))
print(callable(times_five))

# Callable with State

class RunningTotal:
    """
    Maintains a running total each time it is called.
    """

    def __init__(self, start: int = 0) -> None:
        self.total: int = start

    def __call__(self, value: int) -> int:
        self.total += value
        return self.total


accumulator = RunningTotal(10)
print(accumulator(5))
print(accumulator(3))
print(accumulator(7))

"""# Closures

"""

def make_greeter(greeting: str) -> Callable[[str], str]:
    """
    Returns a closure that greets a name with the specified greeting.
    """
    def greeter(name: str) -> str:
        return f"{greeting}, {name}!"
    return greeter

hello = make_greeter("Hello")
namaste = make_greeter("Namaste")

print(hello("Hemanth"))
print(namaste("Lakshman"))

"""# Global Interpreter Lock"""

#GIL

import threading
import time

def fetch_data(index: int) -> None:
    """
    Simulates an I/O-bound operation by sleeping.
    """
    print(f"Thread {index} starting fetch...")
    time.sleep(2)
    print(f"Thread {index} finished fetch.")

threads = []
for i in range(4):
    t = threading.Thread(target=fetch_data, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print("All fetches completed.")

def cpu_intensive_task(n: int) -> int:
    """
    Performs a CPU-bound calculation (summing squares up to n).
    """
    total: int = 0
    for i in range(n):
        total += i * i
    return total


threads = []
for _ in range(4):
    t = threading.Thread(target=cpu_intensive_task, args=(5_000_000,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

print("CPU-bound tasks finished (no real parallel speedup due to GIL).")

"""# Garbage Collection & Reference Collection"""

# RC
a_list = []
b_list = a_list # Both variables reference the same list object
b_list.append(10)
print("a_list:", a_list)
print("b_list:", b_list)

# Reference counts with Sysgetrefcount
import sys
"""
Illustrates how to inspect reference counts of an object
using sys.getrefcount.
"""

my_object = []
print("Initial refcount:", sys.getrefcount(my_object))
# e.g., 2 -> (my_object in this scope + temporary ref in getrefcount)

alias = my_object
print("After aliasing:", sys.getrefcount(my_object))
# e.g., 3 -> (my_object, alias, + temporary)

del alias
print("After del alias:", sys.getrefcount(my_object))
# e.g., 2 -> back down to original references

# Cyclic refernce example

class Node:
    """
    A simple class that can form cycles if nodes reference each other.
    """

    def __init__(self, name: str) -> None:
        self.name: str = name
        self.reference: "Node | None" = None

def create_cycle() -> None:
    """
    Demonstrates a reference cycle that Python's GC must handle.
    """
    node_a = Node("A")
    node_b = Node("B")

    node_a.reference = node_b
    node_b.reference = node_a

    # node_a and node_b reference each other.
    # Even if we delete node_a and node_b here, the cycle remains in memory
    del node_a
    del node_b
    # Without GC, these objects' refcount won't reach 0, but Python's GC will
    # eventually collect them as they are no longer reachable externally.

create_cycle()

# Manual Garbage Collection

import gc

def force_garbage_collection() -> None:
    """
    Demonstrates manually triggering garbage collection to free cycles.
    """
    create_cycle()
    # Force a garbage collection pass
    unreachable_objs = gc.collect()
    print(f"Garbage collector found and freed {unreachable_objs} objects.")

force_garbage_collection()
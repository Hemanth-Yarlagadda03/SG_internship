"""
21Feb-Exercises.ipynb

Automatically generated by Colab.

Original file is located at:
    https://colab.research.google.com/drive/1Jf0DDRUdeUZt2DwwaF3f6_71BVyF2BC_

Class and Static Methods, Iterators, and Generators
"""

from datetime import date
import random
from typing import List, Dict, Generator


# ------------------------------ CLASS & STATIC METHODS ------------------------------ #

class Employee:
    """Employee class with salary management using class methods."""

    roles: Dict[str, int] = {"VP": 500000, "Manager": 150000, "Intern": 30000}

    def __init__(self, name: str, role: str) -> None:
        self.name = name
        self.role = role
        self.salary = self.roles.get(role, 0)

    @classmethod
    def from_dict(cls, data: Dict[str, str]) -> "Employee":
        """Creates an Employee instance from a dictionary."""
        return cls(data["name"], data["role"])

    @classmethod
    def update_salary(cls, role: str, new_salary: int) -> None:
        """Updates the salary for a given role."""
        if role in cls.roles:
            cls.roles[role] = new_salary
        else:
            print(f"Role '{role}' not found.")



emp1 = Employee.from_dict({"name": "Hem", "role": "Intern"})
emp2 = Employee("Lakshman", "Manager")

print(emp1.name, emp1.salary)
print(emp2.name, emp2.salary)

Employee.update_salary("Intern", 50000)
emp3 = Employee("Yarlagadda", "Intern")

print(emp3.name, emp3.salary)


class Person:
    """Person class with static and class methods."""

    def __init__(self, name: str, age: int) -> None:
        self.name = name
        self.age = age

    @classmethod
    def from_birth_year(cls, name: str, year: int) -> "Person":
        """Creates a Person instance using the birth year."""
        return cls(name, date.today().year - year)

    @staticmethod
    def is_adult(age: int) -> bool:
        """Checks if a person is an adult."""
        return age > 18



person1 = Person("Ram", 21)
person2 = Person.from_birth_year("Raj", 2003)

print(person1.age)
print(person2.age)
print(Person.is_adult(14))


# ------------------------------ ITERATORS ------------------------------ #

class SalaryIterator:
    """Iterator for calculating updated salaries."""

    def __init__(self, salaries: List[int]) -> None:
        self.salaries = salaries
        self.index = 0

    def __iter__(self) -> "SalaryIterator":
        return self

    def __next__(self) -> str:
        if self.index >= len(self.salaries):
            raise StopIteration
        salary = self.salaries[self.index] * 1.50
        self.index += 1
        return f"Updated Salary: {salary:.2f}"


salaries = [50000, 60000, 55000]
salary_iterator = SalaryIterator(salaries)

for salary in salary_iterator:
    print(salary)


# ------------------------------ GENERATORS ------------------------------ #

def employee_increment() -> Generator[str, None, None]:
    """Generator function that yields a 20% increment for each salary."""
    salaries = [100000, 200000, 150000]
    for salary in salaries:
        yield f"Increment received: {salary * 0.20:.2f}"



increments = employee_increment()

for increment in increments:
    print(increment)


def salary_role(emp_roles: List[str]) -> Generator[str, None, None]:
    """Generator function that calculates new salaries for roles."""
    base_salaries = {
        "HR": 50000,
        "IT": 60000,
        "Finance": 70000,
        "Marketing": 55000
    }

    for role in emp_roles:
        if role in base_salaries:
            yield f"Role: {role}, New Salary: {base_salaries[role] * 1.20:.2f}"
        else:
            yield f"Role: {role}, No data available"



roles = ["IT", "HR", "Finance", "CEO"]
salary_generator = salary_role(roles)

for salary in salary_generator:
    print(salary)


# ------------------------------ RANDOM EMPLOYEE ID GENERATOR ------------------------------ #

def random_employee_ids() -> Generator[int, None, None]:
    """Generator function that yields random employee IDs indefinitely."""
    while True:
        yield random.randint(100, 999)



id_generator = iter(random_employee_ids())

for _ in range(5):
    print(next(id_generator))


# ------------------------------ LIBRARY MANAGEMENT SYSTEM ------------------------------ #

class Book:
    """Represents a book in the library."""

    lib_name = "SG Library"

    def __init__(self, b_id: int, title: str, author: str, copies: int) -> None:
        """Initializes the Book instance."""
        self.b_id = b_id
        self.title = title
        self.author = author
        self.copies = copies

    def show(self) -> None:
        """Displays book details."""
        print(f"ID: {self.b_id}, {self.title} by {self.author}, Copies: {self.copies}")

    @staticmethod
    def fine(days: int) -> int:
        """Calculates fine for overdue books (50 per day)."""
        return days * 50

    @classmethod
    def set_lib_name(cls, name: str) -> None:
        """Updates the library name."""
        cls.lib_name = name


class BookIterator:
    """Iterator for iterating through a list of books."""

    def __init__(self, books: List[Book]) -> None:
        self.books = books
        self.index = 0

    def __iter__(self) -> "BookIterator":
        return self

    def __next__(self) -> Book:
        if self.index >= len(self.books):
            raise StopIteration
        book = self.books[self.index]
        self.index += 1
        return book


def book_availability(books: List[Book]) -> Generator[str, None, None]:
    """Generator to check book availability."""
    for book in books:
        yield f"{book.title} - Available: {book.copies}" if book.copies > 0 else f"{book.title} - Out of Stock"


class Library:
    """Library management system to handle books."""

    def __init__(self, books: List[Book]) -> None:
        self.books = books

    def list_books(self) -> None:
        """Lists all books in the library."""
        print("\nBooks:")
        for book in BookIterator(self.books):
            book.show()

    def check_availability(self) -> None:
        """Checks availability of books."""
        print("\nAvailability:")
        for book in book_availability(self.books):
            print(book)

    def show_library_name(self) -> None:
        """Displays the library name."""
        print(f"\nLibrary: {Book.lib_name}")



books = [
    Book(1, "1984", "George Orwell", 4),
    Book(2, "Metamorphosis", "Franz Kafka", 2),
    Book(3, "Hippie", "Paulo Coelho", 0)
]

library = Library(books)

library.list_books()
library.check_availability()
library.show_library_name()

Book.set_lib_name("Seg Library")
library.show_library_name()
print(f"{Book.fine(3)} rupees")
